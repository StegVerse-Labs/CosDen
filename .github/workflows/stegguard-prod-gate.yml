name: StegGuard Prod Gate

on:
  workflow_call:
    inputs:
      repo_name:
        description: "Name of the repo as recorded in StegDB (e.g. CosDen)"
        required: true
        type: string

jobs:
  guard:
    name: StegGuard / Prod Gate
    runs-on: ubuntu-latest

    env:
      REPO_NAME: ${{ inputs.repo_name }}

    steps:
      - name: Checkout StegDB
        uses: actions/checkout@v4
        with:
          repository: StegVerse/StegDB
          ref: main
          path: StegDB

      - name: Verify dependency status from StegDB
        working-directory: StegDB
        run: |
          set -euo pipefail

          STATUS_FILE="meta/dependency_status.json"

          if [ ! -f "$STATUS_FILE" ]; then
            echo "::error::StegGuard: ${STATUS_FILE} missing. StegDB full-cycle has not produced dependency status. Failing closed."
            exit 1
          fi

          python - << 'PY'
          import json
          import os
          import pathlib
          import subprocess
          import sys

          repo_name = os.environ["REPO_NAME"]
          status_path = pathlib.Path("meta") / "dependency_status.json"

          # --- Load & parse status file ---
          try:
              data = json.loads(status_path.read_text(encoding="utf-8"))
          except Exception as exc:
              print(f"StegGuard: unable to parse {status_path}: {exc}")
              sys.exit(1)

          # --- Global overall_status check ---
          overall = data.get("overall_status")
          if overall != "ok":
              print(f"StegGuard: overall_status is {overall!r}, expected 'ok'. Failing.")
              issues = data.get("issues") or []
              if issues:
                  print("Global issues:")
                  for issue in issues:
                      print(" -", issue)
              sys.exit(1)

          # --- Per-repo status check ---
          repos = data.get("repos") or {}
          repo = repos.get(repo_name)
          if not repo:
              print(f"StegGuard: repo {repo_name!r} not present in dependency_status.json. Failing.")
              sys.exit(1)

          if repo.get("status") != "ok":
              print(f"StegGuard: repo {repo_name!r} status is {repo.get('status')!r}, expected 'ok'. Failing.")
              issues = repo.get("issues") or []
              if issues:
                  print("Repo issues:")
                  for issue in issues:
                      print(" -", issue)
              sys.exit(1)

          # --- Ensure the status belongs to THIS StegDB commit ---
          recorded_sha = data.get("stegdb_full_cycle_sha")
          try:
              current_sha = subprocess.check_output(
                  ["git", "rev-parse", "HEAD"],
                  text=True,
              ).strip()
          except Exception as exc:
              print("StegGuard: unable to determine current StegDB commit sha:", exc)
              sys.exit(1)

          if recorded_sha and recorded_sha != current_sha:
              print(f"StegGuard: dependency_status.json was generated at StegDB sha {recorded_sha},")
              print(f"           but the current StegDB checkout is {current_sha}. Failing to avoid stale decisions.")
              sys.exit(1)

          print(f"StegGuard: repo {repo_name!r} passes prod gate with overall_status 'ok' at sha {recorded_sha}.")
          PY
